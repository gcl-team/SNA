using Microsoft.Extensions.Logging;
using SimNextgenApp.Configurations;
using SimNextgenApp.Core;
using SimNextgenApp.Demo.CustomModels;
using SimNextgenApp.Statistics;

namespace SimNextgenApp.Demo.Scenarios;

internal static class SimpleMmck
{
    public static void RunDemo(
        ILoggerFactory loggerFactory,
        int numberOfServers,
        int systemCapacityK,
        double meanArrivalSecs,
        double meanServiceSecs,
        double runDuration,
        double warmupDuration,
        int genSeed,
        int serverSeedBase
    )
    {
        var programLogger = loggerFactory.CreateLogger("Program");

        // 1. Generator Configuration
        Func<Random, TimeSpan> interArrivalTimeFunc = (rnd) =>
            TimeSpan.FromSeconds(-meanArrivalSecs * Math.Log(1.0 - rnd.NextDouble()));
        Func<Random, MyLoad> loadFactoryFunc = (rnd) => new MyLoad();
        var generatorConfig = new GeneratorStaticConfig<MyLoad>(interArrivalTimeFunc, loadFactoryFunc)
        { IsSkippingFirst = false };

        // 2. Queue Configuration (Capacity will be overridden by MyMmckSystemModel)
        var queueConfig = new QueueStaticConfig<MyLoad>(); // Uses default infinite, model will set K-c

        // 3. Server Configuration (Template for all servers)
        Func<MyLoad, Random, TimeSpan> serviceTimeFunc = (load, rnd) =>
            TimeSpan.FromSeconds(-meanServiceSecs * Math.Log(1.0 - rnd.NextDouble()));
        var serverConfigTemplate = new ServerStaticConfig<MyLoad>(serviceTimeFunc)
        { Capacity = 1 }; // Each server unit has capacity 1

        // 4. Create the Composite M/M/c/K Model
        var mmckSystem = new SimpleMmckModel(
            generatorConfig, genSeed,
            queueConfig,
            serverConfigTemplate, numberOfServers, serverSeedBase,
            systemCapacityK,
            loggerFactory);

        programLogger.LogInformation($"M/M/c/K System Created: c={mmckSystem.NumberOfServersC}, K={mmckSystem.SystemCapacityK}, Queue Capacity (K-c)={mmckSystem.WaitingLine.Capacity}");

        // 5. Create a Run Strategy
        var runStrategy = new DurationRunStrategy(runDuration, warmupDuration);

        // 6. Create a Memory Tracer to capture simulation events
        var tracer = new MemoryTracer();

        // 7. Create the Simulation Profile
        var simulationProfile = new SimulationProfile(
            model: mmckSystem,
            runStrategy: runStrategy,
            "M/M/c/K Profile",
            SimulationTimeUnit.Seconds,
            loggerFactory: loggerFactory,
            tracer: tracer
        );

        // 8. Create the Simulation Engine
        var simulationEngine = new SimulationEngine(simulationProfile);

        // 9. Run the simulation
        programLogger.LogInformation($"Starting M/M/c/K simulation run for {runDuration} units, warmup {warmupDuration} units...");
        SimulationResult? simulationResult = null;
        try
        {
            simulationResult = simulationEngine.Run();
        }
        catch (Exception ex)
        {
            programLogger.LogCritical(ex, "Simulation run failed!");
        }

        // 10. Report results
        programLogger.LogInformation($"\n--- Simulation Finished --- {simulationResult}");

        programLogger.LogInformation("\n--- Generator Stats (Post-Warmup) ---");
        programLogger.LogInformation($"Loads Generated by '{mmckSystem.LoadGenerator.Name}': {mmckSystem.LoadGenerator.LoadsGeneratedCount}");

        programLogger.LogInformation("\n--- System Stats (Post-Warmup) ---");
        programLogger.LogInformation($"Total Loads Entered System: {mmckSystem.TotalLoadsEnteredSystem}");
        programLogger.LogInformation($"Total Balked Loads (System Full): {mmckSystem.BalkedLoadsCount}");

        programLogger.LogInformation("\n--- Queue Stats ('{QueueName}', Post-Warmup) ---", mmckSystem.WaitingLine.Name);
        var queueMetric = mmckSystem.WaitingLine.TimeBasedMetric;
        programLogger.LogInformation($"Capacity (Waiting Spots): {mmckSystem.WaitingLine.Capacity}");
        programLogger.LogInformation($"Final Occupancy: {mmckSystem.WaitingLine.Occupancy}");
        programLogger.LogInformation($"Average Queue Length: {queueMetric.AverageCount:F3}");
        programLogger.LogInformation($"Max Queue Length Observed (from history if enabled, or need separate tracker)");


        programLogger.LogInformation("\n--- Server Stats (Aggregated for {NumServers} Servers, Post-Warmup) ---", mmckSystem.NumberOfServersC);
        int totalLoadsCompletedByServers = 0;
        double sumOfServerUtilizations = 0;
        double sumOfAvgBusyServerUnits = 0; // Should equal sum of utilizations if capacity 1

        foreach (var server in mmckSystem.ServiceChannels)
        {
            totalLoadsCompletedByServers += server.LoadsCompletedCount;
            sumOfServerUtilizations += server.Utilization; // Assumes Server.Utilization uses its own TimeBasedMetric correctly
            sumOfAvgBusyServerUnits += server.BusyServerUnitsCounter.AverageCount;
            programLogger.LogInformation($"  Server '{server.Name}': Completed={server.LoadsCompletedCount}, AvgBusy={server.BusyServerUnitsCounter.AverageCount:F3} (Util: {server.Utilization:P2})");
        }
        programLogger.LogInformation($"Total Loads Completed by All Servers: {totalLoadsCompletedByServers}");
        programLogger.LogInformation($"Average Server Utilization (avg of individuals): {sumOfServerUtilizations / mmckSystem.NumberOfServersC:P2}");
        programLogger.LogInformation($"Overall Average Busy Servers (sum of individuals): {sumOfAvgBusyServerUnits:F3}");

        // 11. Print the Memory Tracer events
        tracer.PrintToConsole();
    }
}
