using Microsoft.Extensions.Logging;
using SimNextgenApp.Configurations;
using SimNextgenApp.Core;
using SimNextgenApp.Demo.CustomModels;

namespace SimNextgenApp.Demo.Scenarios;

internal static class SimpleMmck
{
    public static void RunDemo() 
    {
        var loggerFactory = LoggerFactory.Create(builder =>
        {
            builder
                .AddFilter("SimNextgenApp", LogLevel.Information) // Adjust log level as needed
                .AddFilter("Default", LogLevel.Information)
                .AddConsole();
        });
        var programLogger = loggerFactory.CreateLogger("Program");

        // --- Simulation Parameters ---
        int numberOfServers = 2; // c
        int systemCapacityK = 5; // K (e.g., 2 in service + 3 in queue)
        // Queue capacity will be K - c = 3

        double meanArrivalSecs = 3.0;  // Average time between arrivals
        double meanServiceSecs = 5.0;  // Average service time per server (lambda < c*mu for stability)
                                       // Arrival rate lambda = 1/3 = 0.333
                                       // Service rate per server mu = 1/5 = 0.2
                                       // c*mu = 2 * 0.2 = 0.4
                                       // Traffic intensity rho = lambda / (c*mu) = 0.333 / 0.4 = 0.8325 < 1 (stable)

        int genSeed = 2024;
        int serverSeedBase = 100;

        double runDuration = 500.0;
        double warmupDuration = 100.0;

        // 1. Generator Configuration
        Func<Random, TimeSpan> interArrivalTimeFunc = (rnd) =>
            TimeSpan.FromSeconds(-meanArrivalSecs * Math.Log(1.0 - rnd.NextDouble()));
        Func<Random, MyLoad> loadFactoryFunc = (rnd) => new MyLoad();
        var generatorConfig = new GeneratorStaticConfig<MyLoad>(interArrivalTimeFunc, loadFactoryFunc)
        { IsSkippingFirst = false };

        // 2. Queue Configuration (Capacity will be overridden by MyMmckSystemModel)
        var queueConfig = new QueueStaticConfig<MyLoad>(); // Uses default infinite, model will set K-c

        // 3. Server Configuration (Template for all servers)
        Func<MyLoad, Random, TimeSpan> serviceTimeFunc = (load, rnd) =>
            TimeSpan.FromSeconds(-meanServiceSecs * Math.Log(1.0 - rnd.NextDouble()));
        var serverConfigTemplate = new ServerStaticConfig<MyLoad>(serviceTimeFunc)
        { Capacity = 1 }; // Each server unit has capacity 1

        // 4. Create the Composite M/M/c/K Model
        var mmckSystem = new SimpleMmckModel(
            generatorConfig, genSeed,
            queueConfig,
            serverConfigTemplate, numberOfServers, serverSeedBase,
            systemCapacityK,
            loggerFactory);

        programLogger.LogInformation($"M/M/c/K System Created: c={mmckSystem.NumberOfServersC}, K={mmckSystem.SystemCapacityK}, Queue Capacity (K-c)={mmckSystem.WaitingLine.Capacity}");

        // 5. Create the SimulationEngine
        var simulationEngine = new SimulationEngine(
            baseTimeUnit: SimulationTimeUnit.Seconds,
            model: mmckSystem,
            loggerFactory: loggerFactory
        );

        // 6. Create a Run Strategy
        var runStrategy = new DurationRunStrategy(runDuration, warmupDuration);

        // 7. Run the simulation
        programLogger.LogInformation($"Starting M/M/c/K simulation run for {runDuration} units, warmup {warmupDuration} units...");
        try
        {
            simulationEngine.Run(runStrategy);
        }
        catch (Exception ex)
        {
            programLogger.LogCritical(ex, "Simulation run failed!");
        }

        // 8. Report results
        programLogger.LogInformation("\n--- Simulation Finished ---");
        programLogger.LogInformation($"Final Simulation Clock Time: {simulationEngine.ClockTime:F2}");
        programLogger.LogInformation($"Total Events Executed: {simulationEngine.ExecutedEventCount}");

        programLogger.LogInformation("\n--- Generator Stats (Post-Warmup) ---");
        programLogger.LogInformation($"Loads Generated by '{mmckSystem.LoadGenerator.Name}': {mmckSystem.LoadGenerator.LoadsGeneratedCount}");

        programLogger.LogInformation("\n--- System Stats (Post-Warmup) ---");
        programLogger.LogInformation($"Total Loads Entered System: {mmckSystem.TotalLoadsEnteredSystem}");
        programLogger.LogInformation($"Total Balked Loads (System Full): {mmckSystem.BalkedLoadsCount}");

        programLogger.LogInformation("\n--- Queue Stats ('{QueueName}', Post-Warmup) ---", mmckSystem.WaitingLine.Name);
        var queueMetric = mmckSystem.WaitingLine.TimeBasedMetric;
        programLogger.LogInformation($"Capacity (Waiting Spots): {mmckSystem.WaitingLine.Capacity}");
        programLogger.LogInformation($"Final Occupancy: {mmckSystem.WaitingLine.Occupancy}");
        programLogger.LogInformation($"Average Queue Length: {queueMetric.AverageCount:F3}");
        programLogger.LogInformation($"Max Queue Length Observed (from history if enabled, or need separate tracker)");


        programLogger.LogInformation("\n--- Server Stats (Aggregated for {NumServers} Servers, Post-Warmup) ---", mmckSystem.NumberOfServersC);
        int totalLoadsCompletedByServers = 0;
        double sumOfServerUtilizations = 0;
        double sumOfAvgBusyServerUnits = 0; // Should equal sum of utilizations if capacity 1

        foreach (var server in mmckSystem.ServiceChannels)
        {
            totalLoadsCompletedByServers += server.LoadsCompletedCount;
            sumOfServerUtilizations += server.Utilization; // Assumes Server.Utilization uses its own TimeBasedMetric correctly
            sumOfAvgBusyServerUnits += server.BusyServerUnitsCounter.AverageCount;
            programLogger.LogInformation($"  Server '{server.Name}': Completed={server.LoadsCompletedCount}, AvgBusy={server.BusyServerUnitsCounter.AverageCount:F3} (Util: {server.Utilization:P2})");
        }
        programLogger.LogInformation($"Total Loads Completed by All Servers: {totalLoadsCompletedByServers}");
        programLogger.LogInformation($"Average Server Utilization (avg of individuals): {sumOfServerUtilizations / mmckSystem.NumberOfServersC:P2}");
        programLogger.LogInformation($"Overall Average Busy Servers (sum of individuals): {sumOfAvgBusyServerUnits:F3}");
    }
}
