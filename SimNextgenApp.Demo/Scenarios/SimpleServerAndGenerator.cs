using Microsoft.Extensions.Logging;
using SimNextgenApp.Configurations;
using SimNextgenApp.Core;
using SimNextgenApp.Demo.CustomModels;
using SimNextgenApp.Statistics;

namespace SimNextgenApp.Demo.Scenarios;

internal static class SimpleServerAndGenerator
{
    public static void RunDemo(ILoggerFactory loggerFactory, double meanArrivalSeconds) 
    {
        var programLogger = loggerFactory.CreateLogger("Program");

        // 1. Generator Configuration
        Func<Random, TimeSpan> interArrivalTimeFunc = (rnd) =>
        {
            return TimeSpan.FromSeconds(-meanArrivalSeconds * Math.Log(1.0 - rnd.NextDouble()));
        };
        Func<Random, MyLoad> loadFactoryFunc = (rnd) => new MyLoad();
        var generatorConfig = new GeneratorStaticConfig<MyLoad>(interArrivalTimeFunc, loadFactoryFunc)
        {
            IsSkippingFirst = false
        };

        // 2. Server Configuration
        int serverCapacity = 1; // Single server
        Func<MyLoad, Random, TimeSpan> serviceTimeFunc = (load, rnd) =>
        {
            double meanServiceSeconds = 8.0;
            return TimeSpan.FromSeconds(-meanServiceSeconds * Math.Log(1.0 - rnd.NextDouble()));
        };

        // Create ServerStaticConfig using its constructor and then set Capacity if not infinite
        var serverConfig = new ServerStaticConfig<MyLoad>(serviceTimeFunc)
        {
            Capacity = serverCapacity
        };

        // 3. Create the Composite Model
        var simpleSystem = new GeneratorAndServerModel(
            generatorConfig, 123,
            serverConfig, 456,
            loggerFactory);

        // 4. Create a Run Strategy
        double runDuration = 100.0;
        double warmupDuration = 20.0;
        var runStrategy = new DurationRunStrategy(runDuration, warmupDuration);

        // 5. Create the Simulation Profile
        var simulationProfile = new SimulationProfile(
            model: simpleSystem,
            runStrategy: runStrategy,
            "Simple Server and Generator Profile",
            SimulationTimeUnit.Seconds,
            loggerFactory: loggerFactory
        );

        // 6. Create the Simulation Engine
        var simulationEngine = new SimulationEngine(simulationProfile);

        // 7. Run the simulation
        SimulationResult? simulationResult = null;
        programLogger.LogInformation($"Starting simulation run for {runDuration} units, warmup {warmupDuration} units...");
        try
        {
            simulationResult = simulationEngine.Run();
        }
        catch (Exception ex)
        {
            programLogger.LogCritical(ex, "Simulation run failed!");
        }

        // 7. Report results
        programLogger.LogInformation($"\n--- Simulation Finished --- {simulationResult}");

        programLogger.LogInformation("\n--- Generator Stats ---");
        programLogger.LogInformation($"Loads Generated by '{simpleSystem.LoadGenerator.Name}': {simpleSystem.LoadGenerator.LoadsGeneratedCount}");

        programLogger.LogInformation("\n--- Server Stats ({ServerName}) ---", simpleSystem.ServicePoint.Name);
        programLogger.LogInformation($"Capacity: {simpleSystem.ServicePoint.Capacity}");
        programLogger.LogInformation($"Loads Completed Service (post-warmup): {simpleSystem.ServicePoint.LoadsCompletedCount}");
        programLogger.LogInformation($"Loads Currently In Service: {simpleSystem.ServicePoint.NumberInService}");

        // Access TimeBasedMetric from the server
        var busyServerMetric = simpleSystem.ServicePoint.BusyServerUnitsCounter;

        // The TimeBasedMetric's WarmedUp method sets its InitialTime.
        // Its CurrentTime is the time of the last observation.
        // AverageCount will be calculated over TotalActiveDuration (from InitialTime to CurrentTime).
        programLogger.LogInformation($"Server Utilization (post-warmup): {simpleSystem.ServicePoint.Utilization:P2}");
        programLogger.LogInformation($"  Avg Busy Servers (post-warmup): {busyServerMetric.AverageCount:F3}");
        programLogger.LogInformation($"  Total Active Duration for Metric (post-warmup): {busyServerMetric.TotalActiveDuration:F2}");
        programLogger.LogInformation($"  Metric Initial Time: {busyServerMetric.InitialTime:F2}, Metric Current Time: {busyServerMetric.CurrentTime:F2}");


        programLogger.LogInformation($"\n--- System Stats ---");
        programLogger.LogInformation($"Total Balked Loads (post-warmup): {simpleSystem.BalkedLoadsCount}");

        // Display more TimeBasedMetric stats
        programLogger.LogInformation("\n--- Detailed Server Busy Units Metric (post-warmup) ---");
        programLogger.LogInformation($"Total Increments (servers becoming busy): {busyServerMetric.TotalIncrementObserved}");
        programLogger.LogInformation($"Total Decrements (servers becoming free): {busyServerMetric.TotalDecrementObserved}");
        programLogger.LogInformation($"Increment Rate: {busyServerMetric.IncrementRate:F4} per unit time");
        programLogger.LogInformation($"Decrement Rate (Throughput): {busyServerMetric.DecrementRate:F4} per unit time");
        programLogger.LogInformation($"Observation Coverage: {busyServerMetric.ObservationCoverageRatio:P2}");
        programLogger.LogInformation($"Estimated Avg Sojourn Time (Little's Law): {busyServerMetric.AverageSojournTime:F3}");

        try
        {
            programLogger.LogInformation($"Count at 95th Percentile by Time: {busyServerMetric.GetCountPercentileByTime(95)}");
            programLogger.LogInformation($"Count at 50th Percentile by Time: {busyServerMetric.GetCountPercentileByTime(50)}");
        }
        catch (Exception ex)
        {
            programLogger.LogError(ex, "Error getting percentiles from TimeBasedMetric.");
        }


        programLogger.LogInformation("\nTime spent at each server count level (post-warmup):");
        if (busyServerMetric.TimePerCount.Any())
        {
            foreach (var kvp in busyServerMetric.TimePerCount.OrderBy(k => k.Key))
            {
                programLogger.LogInformation($"  Count {kvp.Key}: {kvp.Value:F2} time units ({kvp.Value / busyServerMetric.TotalActiveDuration:P2})");
            }
        }
        else
        {
            programLogger.LogInformation("  No data for time per count.");
        }

        programLogger.LogInformation("\nHistogram of Server Busy Units (Interval Width 1, post-warmup):");
        try
        {
            var histogram = busyServerMetric.GenerateHistogram(1.0);
            if (histogram.Any())
            {
                programLogger.LogInformation("  Bin_Lower | Total_Time | Probability | Cumulative_Probability");
                programLogger.LogInformation("  -------------------------------------------------------------");
                foreach (var bin in histogram)
                {
                    programLogger.LogInformation($"  {bin.CountLowerBound,-9:F1} | {bin.TotalTime,-10:F2} | {bin.Probability,-11:P2} | {bin.CumulativeProbability,-10:P2}");
                }
            }
            else
            {
                programLogger.LogInformation("  No data for histogram.");
            }
        }
        catch (Exception ex)
        {
            programLogger.LogError(ex, "Error generating histogram from TimeBasedMetric.");
        }
    }
}