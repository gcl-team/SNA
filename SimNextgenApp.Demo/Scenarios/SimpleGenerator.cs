using Microsoft.Extensions.Logging;
using SimNextgenApp.Configurations;
using SimNextgenApp.Core;
using SimNextgenApp.Demo.CustomModels;

namespace SimNextgenApp.Demo.Scenarios;

internal static class SimpleGenerator
{
    public static void RunDemo(ILoggerFactory loggerFactory) 
    {

        // 1. Create the GeneratorStaticConfig
        //    Define how loads are created and their arrival pattern.

        // Example: Inter-arrival time is exponentially distributed with a mean of 10.0 time units.
        // We assume 1 simulation time unit = 1 second for this example's TimeSpan conversion.
        Func<Random, TimeSpan> interArrivalTimeFunc = (rnd) =>
        {
            double meanArrivalSeconds = 10.0;
            // For exponential distribution: -mean * ln(U), where U is random [0,1)
            double timeInSeconds = -meanArrivalSeconds * Math.Log(1.0 - rnd.NextDouble());
            return TimeSpan.FromSeconds(timeInSeconds);
        };

        // Example: Load factory simply creates a new MyLoad instance.
        Func<Random, MyLoad> loadFactoryFunc = (rnd) =>
        {
            // The 'rnd' could be used here to initialize MyLoad properties randomly if needed
            return new MyLoad();
        };

        var generatorConfig = new GeneratorStaticConfig<MyLoad>(
            interArrivalTime: interArrivalTimeFunc,
            loadFactory: loadFactoryFunc
        )
        {
            IsSkippingFirst = false // For this demo, let's not skip the first one
        };

        // 2. Create the Generator instance
        //    The generator will be our entire simulation model in this simple case.
        //    It needs a seed for its internal Random instance and a name.
        int randomSeed = 12345;
        var myGenerator = new Generator<MyLoad>(
            config: generatorConfig,
            seed: randomSeed,
            instanceName: "CustomerArrivalGenerator",
            loggerFactory: loggerFactory
        );

        // 3. (CRUCIAL FOR GENERATOR) Tell the Generator what to do when a load is generated.
        //    This connects the generator's output.
        myGenerator.LoadGeneratedActions.Add((load, generationTime) =>
        {
            load.CreationTime = generationTime; // Set the actual creation time
                                                // In a real model, you'd send this load to a queue, a server, etc.
                                                // For now, we just log it.
                                                // Note: This lambda might capture 'loggerFactory' or a specific logger if needed.
            var consoleLogger = loggerFactory.CreateLogger("LoadHandler");
            consoleLogger.LogInformation($"--- [LOAD GENERATED] SimTime: {generationTime:F2} -> {load} ---");
        });

        // 4. Create the SimulationEngine
        var simulationEngine = new SimulationEngine(
            baseTimeUnit: SimulationTimeUnit.Seconds, // Defines what 1.0 in ClockTime means
            model: myGenerator,                       // The generator is our model
            loggerFactory: loggerFactory
        );

        // 5. Create a Run Strategy
        var runStrategy = new DurationRunStrategy(50.0);

        // 6. Run the simulation
        try
        {
            simulationEngine.Run(runStrategy);
        }
        catch (Exception ex)
        {
            var errorLogger = loggerFactory.CreateLogger("SimulationRun");
            errorLogger.LogCritical(ex, "Simulation run failed!");
        }

        // 7. Report results/stats from the engine or model
        Console.WriteLine("\nSimulation finished.");
        Console.WriteLine($"Final Simulation Clock Time: {simulationEngine.ClockTime:F2}");
        Console.WriteLine($"Total Events Executed: {simulationEngine.ExecutedEventCount}");
        Console.WriteLine($"Total Loads Generated by '{myGenerator.Name}': {myGenerator.LoadsGeneratedCount}");
        Console.WriteLine($"Real-time duration for last run: {simulationEngine.RealTimeDurationForLastRun?.TotalMilliseconds:F2} ms");
    }
}
