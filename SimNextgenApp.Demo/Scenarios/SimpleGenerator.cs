using Microsoft.Extensions.Logging;
using Serilog;
using SimNextgenApp.Configurations;
using SimNextgenApp.Core;
using SimNextgenApp.Core.Strategies;
using SimNextgenApp.Core.Utilities;
using SimNextgenApp.Demo.CustomModels;
using SimNextgenApp.Modeling.Generator;
using SimNextgenApp.Statistics;

namespace SimNextgenApp.Demo.Scenarios;

internal static class SimpleGenerator
{
    public static void RunDemo(ILoggerFactory loggerFactory) 
    {
        // 1. Create the GeneratorStaticConfig
        //    Define how loads are created and their arrival pattern.

        // Example: Inter-arrival time is exponentially distributed with a mean of 10.0 time units.
        // We assume 1 simulation time unit = 1 second for this example's TimeSpan conversion.
        Func<Random, TimeSpan> interArrivalTimeFunc = (rnd) =>
        {
            double meanArrivalSeconds = 10.0;
            // For exponential distribution: -mean * ln(U), where U is random [0,1)
            double timeInSeconds = -meanArrivalSeconds * Math.Log(1.0 - rnd.NextDouble());
            return TimeSpan.FromSeconds(timeInSeconds);
        };

        // Example: Load factory simply creates a new MyLoad instance.
        Func<Random, MyLoad> loadFactoryFunc = (rnd) =>
        {
            // The 'rnd' could be used here to initialize MyLoad properties randomly if needed
            return new MyLoad();
        };

        var generatorConfig = new GeneratorStaticConfig<MyLoad>(
            interArrivalTime: interArrivalTimeFunc,
            loadFactory: loadFactoryFunc
        )
        {
            IsSkippingFirst = false // For this demo, let's not skip the first one
        };

        // 2. Create the Generator instance
        //    The generator will be our entire simulation model in this simple case.
        //    It needs a seed for its internal Random instance and a name.
        int randomSeed = 12345;
        var myGenerator = new Generator<MyLoad>(
            config: generatorConfig,
            seed: randomSeed,
            instanceName: "CustomerArrivalGenerator",
            loggerFactory: loggerFactory
        );

        // 3. (CRUCIAL FOR GENERATOR) Tell the Generator what to do when a load is generated.
        //    This connects the generator's output.
        myGenerator.LoadGenerated += (load, generationTime) =>
        {
            load.CreationTime = generationTime; // Set the actual creation time
                                                // In a real model, you'd send this load to a queue, a server, etc.
                                                // For now, we just log it.
            var consoleLogger = loggerFactory.CreateLogger("LoadHandler");
            consoleLogger.LogInformation(
                "--- [LOAD GENERATED] SimTime: {SimTime:F2} -> {LoadDetails} ---",
                generationTime,
                load);
        };

        // 4. Create the tracer using the GLOBAL Serilog logger.
        var runStrategy = new DurationRunStrategy(50.0);

        // 5. The SeqTracer records every event that is scheduled and executed.
        var tracer = new SeqTracer(Log.Logger);

        // 6. Create the Simulation Profile to bundle all settings for a reproducible run
        //    This is useful for managing complex simulations with many parameters.
        var simulationProfile = new SimulationProfile(
            model: myGenerator,
            runStrategy: runStrategy,
            "Simple Generator Profile",
            SimulationTimeUnit.Seconds,
            loggerFactory: loggerFactory,
            tracer: tracer
        );

        // 7. Create and run the Simulation Engine
        var simulationEngine = new SimulationEngine(simulationProfile);

        SimulationResult? simulationResult = null;
        try
        {
            simulationResult = simulationEngine.Run();
        }
        catch (Exception ex)
        {
            var errorLogger = loggerFactory.CreateLogger("SimulationRun");
            errorLogger.LogCritical(ex, "Simulation run failed!");
        }
        finally
        {
            // Ensure all buffered logs are sent to Seq before the app closes.
            Log.CloseAndFlush();
        }

        // 8. Report results and diagnostics
        Console.WriteLine($"\nSimulation finished. {simulationResult}");
        Console.WriteLine($"Total Loads Generated by '{myGenerator.Name}': {myGenerator.LoadsGeneratedCount}");
    }
}
